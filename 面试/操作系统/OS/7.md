#### 进程的基本操作

以Unix系统举例：

1. 进程的创建：fork()。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。fork函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明 确的方法来分辨程序是在父进程还是在子进程中执行。

```C++
pid_t fork(void);
```



2. 回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被
  保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程
  时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用
  waitpid 函数来等待它的子进程终止或者停止。

  ```C
  pid_t waitpid(pid_t pid, int *statusp, int options);
  ```

  

3. 加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序。

  ```C
  int execve(const char *filename, const char *argv[], const char *envp[]);
  ```

  

4. 进程终止：

  ```C
  void exit(int status);
  ```

  